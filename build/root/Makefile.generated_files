# Copyright 2016 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Don't allow users to call this directly.  There are too many variables this
# assumes to inherit from the main Makefile.  This is not a user-facing file.
ifeq ($(CALLED_FROM_MAIN_MAKEFILE),)
    $(error Please use the main Makefile, e.g. `make generated_files`)
endif

# Don't allow an implicit 'all' rule.  This is not a user-facing file.
ifeq ($(MAKECMDGOALS),)
    $(error This Makefile requires an explicit rule to be specified)
endif

ifeq ($(DBG_MAKEFILE),1)
    $(warning ***** starting Makefile.generated_files for goal(s) "$(MAKECMDGOALS)")
    $(warning ***** $(shell date))
endif


# It's necessary to set this because some environments don't link sh -> bash.
SHELL := /bin/bash

# This rule collects all the generated file sets into a single rule.  Other
# rules should depend on this to ensure generated files are rebuilt.
.PHONY: generated_files
generated_files: gen_deepcopy 

##TH##FIXMEgen_defaulter gen_conversion gen_openapi gen_bindata


#
# Helper logic to calculate Go's dependency DAG ourselves.
#

# This is a file that will be emitted by the go2make tool, containing a
# variable for each Go package in the project (including deps) which lists all
# of the transitive deps of that package.  Each variable is named the same as
# the package - for example the variable for `k8s.io/kubernetes/pkg/api` is
# $(k8s.io/kubernetes/pkg/api).  This is roughly the same DAG that the Go
# compiler uses.  These variables can be used to figure out if, for example,
# generated code needs to be regenerated.
GO_PKGDEPS_FILE = go-pkgdeps.mk

# Include the Go package dependencies file.  This will cause the rule of
# the same name to be considered and if it is updated, make will restart and
# reload the updated deps.
sinclude $(META_DIR)/$(GO_PKGDEPS_FILE)

# Update the set of Go deps for our project.  This will let us determine if
# we really need to do expensive codegen.  We use FORCE because it is not a
# PHONY file, but we do want it to be re-evaluated every time make is run.  The
# file will only be touched if it actually changes.
$(META_DIR)/$(GO_PKGDEPS_FILE): FORCE
	if [[ "$(DBG_CODEGEN)" == 1 ]]; then          \
	    echo "DBG: calculating Go dependencies";  \
	fi
	hack/run-in-gopath.sh go install ./hack/make-rules/helpers/go2make
	hack/run-in-gopath.sh go2make                    \
	    k8s.io/kubernetes/...                        \
	    --prune  k8s.io/kubernetes/staging           \
	    --prune  k8s.io/kubernetes/vendor            \
	    k8s.io/kubernetes/vendor/k8s.io/...          \
	    > $@.tmp
	if ! cmp -s $@.tmp $@; then                      \
	    if [[ "$(DBG_CODEGEN)" == 1 ]]; then         \
	        echo "DBG: $(GO_PKGDEPS_FILE) changed";  \
	    fi;                                          \
	    cat $@.tmp > $@;                             \
	fi
	rm -f $@.tmp

.PHONY: FORCE
FORCE:

#
# Helper logic to find which directories need codegen as quickly as possible.
#

# This variable holds a list of every directory that contains Go files in this
# project.  Other rules and variables can use this as a starting point to
# reduce filesystem accesses.
ifeq ($(DBG_MAKEFILE),1)
    $(warning ***** finding all *.go dirs)
endif
ALL_GO_DIRS := $(shell                                                   \
    hack/make-rules/helpers/cache_go_dirs.sh $(META_DIR)/all_go_dirs.mk  \
)

# Generate a list of all files that have a `+k8s:` comment-tag.  This will be
# used to derive lists of files/dirs for generation tools.
ifeq ($(DBG_MAKEFILE),1)
    $(warning ***** finding all +k8s: tags)
endif
ALL_K8S_TAG_FILES := $(shell                             \
    find $(ALL_GO_DIRS) -maxdepth 1 -type f -name \*.go  \
        | xargs grep --color=never -l '^// *+k8s:'       \
)


#
# Code generation logic.
#


# Deep-copy generation
#
# Any package that wants deep-copy functions generated must include a
# comment-tag in column 0 of one file of the form:
#     // +k8s:deepcopy-gen=<VALUE>
#
# The <VALUE> may be one of:
#     generate: generate deep-copy functions into the package
#     register: generate deep-copy functions and register them with a
#               scheme

# The result file, in each pkg, of deep-copy generation.
DEEPCOPY_BASENAME := $(GENERATED_FILE_PREFIX)deepcopy
DEEPCOPY_FILENAME := $(DEEPCOPY_BASENAME).go

# The tool used to generate deep copies.
DEEPCOPY_GEN := $(BIN_DIR)/deepcopy-gen

# Find all the directories that request deep-copy generation.
ifeq ($(DBG_MAKEFILE),1)
    $(warning ***** finding all +k8s:deepcopy-gen tags)
endif
DEEPCOPY_DIRS := $(shell                                             \
    grep --color=never -l '+k8s:deepcopy-gen=' $(ALL_K8S_TAG_FILES)  \
        | xargs -n1 dirname                                          \
        | LC_ALL=C sort -u                                           \
)
DEEPCOPY_FILES := $(addsuffix /$(DEEPCOPY_FILENAME), $(DEEPCOPY_DIRS))

# Reset the list of packages that need generation.
$(shell mkdir -p $$(dirname $(META_DIR)/$(DEEPCOPY_GEN)))
$(shell rm -f $(META_DIR)/$(DEEPCOPY_GEN).todo)

# This rule aggregates the set of files to generate and then generates them all
# in a single run of the tool.
.PHONY: gen_deepcopy
gen_deepcopy: $(DEEPCOPY_GEN) $(META_DIR)/$(DEEPCOPY_GEN).todo
	if [[ -s $(META_DIR)/$(DEEPCOPY_GEN).todo ]]; then                 \
	    pkgs=$$(cat $(META_DIR)/$(DEEPCOPY_GEN).todo | paste -sd, -);  \
	    if [[ "$(DBG_CODEGEN)" == 1 ]]; then                           \
	        echo "DBG: running $(DEEPCOPY_GEN) for $$pkgs";            \
	    fi;                                                            \
	    ./hack/run-in-gopath.sh $(DEEPCOPY_GEN)                        \
	        --v $(KUBE_VERBOSE)                                        \
	        --logtostderr                                              \
	        -i "$$pkgs"                                                \
	        --bounding-dirs $(PRJ_SRC_PATH),"k8s.io/api"               \
	        -O $(DEEPCOPY_BASENAME)                                    \
	        "$$@";                                                     \
	fi                                                                 \

# For each dir in DEEPCOPY_DIRS, this establishes a dependency between the
# output file and the input files that should trigger a rebuild.
#
# Note that this is a deps-only statement, not a full rule (see below).  This
# has to be done in a distinct step because wildcards don't work in static
# pattern rules.
#
# The '$(eval)' is needed because this has a different RHS for each LHS, and
# would otherwise produce results that make can't parse.
$(foreach dir, $(DEEPCOPY_DIRS), $(eval                     \
    $(dir)/$(DEEPCOPY_FILENAME): $($(PRJ_SRC_PATH)/$(dir))  \
))

# How to regenerate deep-copy code.  This is a little slow to run, so we batch
# it up and trigger the batch from the 'generated_files' target.
$(META_DIR)/$(DEEPCOPY_GEN).todo: $(DEEPCOPY_FILES)

$(DEEPCOPY_FILES): $(DEEPCOPY_GEN)
	if [[ "$(DBG_CODEGEN)" == 1 ]]; then        \
	    echo "DBG: deepcopy needed $(@D): $?";  \
	    ls -lf --full-time $@ $? || true;       \
	fi
	echo $(PRJ_SRC_PATH)/$(@D) >> $(META_DIR)/$(DEEPCOPY_GEN).todo

# How to build the generator tool.  The deps for this are defined in
# the $(GO_PKGDEPS_FILE), above.
#
# A word on the need to touch: This rule might trigger if, for example, a
# non-Go file was added or deleted from a directory on which this depends.
# This target needs to be reconsidered, but Go realizes it doesn't actually
# have to be rebuilt.  In that case, make will forever see the dependency as
# newer than the binary, and try to "rebuild" it over and over.  So we touch
# it, and make is happy.
$(DEEPCOPY_GEN): $(k8s.io/kubernetes/vendor/k8s.io/code-generator/cmd/deepcopy-gen)
	hack/make-rules/build.sh ./vendor/k8s.io/code-generator/cmd/deepcopy-gen
	touch $@


##TH### Defaulter generation
##TH###
##TH### Any package that wants defaulter functions generated must include a
##TH### comment-tag in column 0 of one file of the form:
##TH###     // +k8s:defaulter-gen=<VALUE>
##TH###
##TH### The <VALUE> depends on context:
##TH###     on types:
##TH###       true:  always generate a defaulter for this type
##TH###       false: never generate a defaulter for this type
##TH###     on functions:
##TH###       covers: if the function name matches SetDefault_NAME, instructs
##TH###               the generator not to recurse
##TH###     on packages:
##TH###       FIELDNAME: any object with a field of this name is a candidate
##TH###                  for having a defaulter generated
##TH##
##TH### The result file, in each pkg, of defaulter generation.
##TH##DEFAULTER_BASENAME := $(GENERATED_FILE_PREFIX)defaults
##TH##DEFAULTER_FILENAME := $(DEFAULTER_BASENAME).go
##TH##
##TH### The tool used to generate defaulters.
##TH##DEFAULTER_GEN := $(BIN_DIR)/defaulter-gen
##TH##
##TH### All directories that request any form of defaulter generation.
##TH##ifeq ($(DBG_MAKEFILE),1)
##TH##    $(warning ***** finding all +k8s:defaulter-gen tags)
##TH##endif
##TH##DEFAULTER_DIRS := $(shell                                            \
##TH##    grep --color=never -l '+k8s:defaulter-gen=' $(ALL_K8S_TAG_FILES) \
##TH##        | xargs -n1 dirname                                          \
##TH##        | LC_ALL=C sort -u                                           \
##TH##)
##TH##
##TH##DEFAULTER_FILES := $(addsuffix /$(DEFAULTER_FILENAME), $(DEFAULTER_DIRS))
##TH##
##TH### This rule aggregates the set of files to generate and then generates them all
##TH### in a single run of the tool.
##TH##.PHONY: gen_defaulter
##TH##gen_defaulter: $(DEFAULTER_FILES) $(DEFAULTER_GEN)
##TH##	if [[ -s $(META_DIR)/$(DEFAULTER_GEN).todo ]]; then                 \
##TH##	    pkgs=$$(cat $(META_DIR)/$(DEFAULTER_GEN).todo | paste -sd, -);  \
##TH##	    if [[ "$(DBG_CODEGEN)" == 1 ]]; then                            \
##TH##	        echo "DBG: running $(DEFAULTER_GEN) for $$pkgs";            \
##TH##	    fi;                                                             \
##TH##	    ./hack/run-in-gopath.sh $(DEFAULTER_GEN)                        \
##TH##	        --v $(KUBE_VERBOSE)                                         \
##TH##	        --logtostderr                                               \
##TH##	        -i "$$pkgs"                                                 \
##TH##	        --extra-peer-dirs $$(echo $(addprefix $(PRJ_SRC_PATH)/, $(DEFAULTER_DIRS)) | sed 's/ /,/g') \
##TH##	        -O $(DEFAULTER_BASENAME)                                    \
##TH##	        "$$@";                                                      \
##TH##	fi
##TH##
##TH### For each dir in DEFAULTER_DIRS, this establishes a dependency between the
##TH### output file and the input files that should trigger a rebuild.
##TH###
##TH### The variable value was set in $(GOFILES_META) and included as part of the
##TH### dependency management logic.
##TH###
##TH### Note that this is a deps-only statement, not a full rule (see below).  This
##TH### has to be done in a distinct step because wildcards don't work in static
##TH### pattern rules.
##TH###
##TH### The '$(eval)' is needed because this has a different RHS for each LHS, and
##TH### would otherwise produce results that make can't parse.
##TH###
##TH### We depend on the $(GOFILES_META).stamp to detect when the set of input files
##TH### has changed.  This allows us to detect deleted input files.
##TH##$(foreach dir, $(DEFAULTER_DIRS), $(eval                                    \
##TH##    $(dir)/$(DEFAULTER_FILENAME): $(META_DIR)/$(dir)/$(GOFILES_META).stamp  \
##TH##                                   $(gofiles__$(dir))                       \
##TH##))
##TH##
##TH### For each dir in DEFAULTER_DIRS, for each target in $(defaulters__$(dir)),
##TH### this establishes a dependency between the output file and the input files
##TH### that should trigger a rebuild.
##TH###
##TH### The variable value was set in $(GOFILES_META) and included as part of the
##TH### dependency management logic.
##TH###
##TH### Note that this is a deps-only statement, not a full rule (see below).  This
##TH### has to be done in a distinct step because wildcards don't work in static
##TH### pattern rules.
##TH###
##TH### The '$(eval)' is needed because this has a different RHS for each LHS, and
##TH### would otherwise produce results that make can't parse.
##TH###
##TH### We depend on the $(GOFILES_META).stamp to detect when the set of input files
##TH### has changed.  This allows us to detect deleted input files.
##TH##$(foreach dir, $(DEFAULTER_DIRS),                                               \
##TH##    $(foreach tgt, $(defaulters__$(dir)), $(eval                                \
##TH##        $(dir)/$(DEFAULTER_FILENAME): $(META_DIR)/$(tgt)/$(GOFILES_META).stamp  \
##TH##                                       $(gofiles__$(tgt))                       \
##TH##    ))                                                                          \
##TH##)
##TH##
##TH### Unilaterally remove any leftovers from previous runs.
##TH##$(shell rm -f $(META_DIR)/$(DEFAULTER_GEN)*.todo)
##TH##
##TH### How to regenerate defaulter code.  This is a little slow to run, so we batch
##TH### it up and trigger the batch from the 'generated_files' target.
##TH##$(DEFAULTER_FILES): $(DEFAULTER_GEN)
##TH##	mkdir -p $$(dirname $(META_DIR)/$(DEFAULTER_GEN))
##TH##	if [[ "$(DBG_CODEGEN)" == 1 ]]; then         \
##TH##	    echo "DBG: defaulter needed $(@D): $?";  \
##TH##	    ls -lf --full-time $@ $? || true;        \
##TH##	fi
##TH##	echo $(PRJ_SRC_PATH)/$(@D) >> $(META_DIR)/$(DEFAULTER_GEN).todo
##TH##
##TH### This calculates the dependencies for the generator tool, so we only rebuild
##TH### it when needed.  It is PHONY so that it always runs, but it only updates the
##TH### file if the contents have actually changed.  We 'sinclude' this later.
##TH##.PHONY: $(META_DIR)/$(DEFAULTER_GEN).mk
##TH##$(META_DIR)/$(DEFAULTER_GEN).mk:
##TH##	mkdir -p $(@D);                                                       \
##TH##	(echo -n "$(DEFAULTER_GEN): ";                                        \
##TH##	 ./hack/run-in-gopath.sh go list                                      \
##TH##	     -f '{{.ImportPath}}{{"\n"}}{{range .Deps}}{{.}}{{"\n"}}{{end}}'  \
##TH##	     ./vendor/k8s.io/code-generator/cmd/defaulter-gen                 \
##TH##	     | grep --color=never "^$(PRJ_SRC_PATH)/"                         \
##TH##	     | xargs ./hack/run-in-gopath.sh go list                          \
##TH##	         -f '{{$$d := .Dir}}{{$$d}}{{"\n"}}{{range .GoFiles}}{{$$d}}/{{.}}{{"\n"}}{{end}}'  \
##TH##	     | paste -sd' ' -                                                 \
##TH##	     | sed 's/ / \\=,/g'                                              \
##TH##	     | tr '=,' '\n\t'                                                 \
##TH##	     | sed "s|$$(pwd -P)/||";                                         \
##TH##	) > $@.tmp;                                                           \
##TH##	if ! cmp -s $@.tmp $@; then                                           \
##TH##	    if [[ "$(DBG_CODEGEN)" == 1 ]]; then                              \
##TH##	        echo "DBG: $(DEFAULTER_GEN).mk changed";                      \
##TH##	    fi;                                                               \
##TH##	    cat $@.tmp > $@;                                                  \
##TH##	    rm -f $@.tmp;                                                     \
##TH##	fi
##TH##
##TH### Include dependency info for the generator tool.  This will cause the rule of
##TH### the same name to be considered and if it is updated, make will restart.
##TH##sinclude $(META_DIR)/$(DEFAULTER_GEN).mk
##TH##
##TH### How to build the generator tool.  The deps for this are defined in
##TH### the $(DEFAULTER_GEN).mk, above.
##TH###
##TH### A word on the need to touch: This rule might trigger if, for example, a
##TH### non-Go file was added or deleted from a directory on which this depends.
##TH### This target needs to be reconsidered, but Go realizes it doesn't actually
##TH### have to be rebuilt.  In that case, make will forever see the dependency as
##TH### newer than the binary, and try to rebuild it over and over.  So we touch it,
##TH### and make is happy.
##TH##$(DEFAULTER_GEN):
##TH##	hack/make-rules/build.sh ./vendor/k8s.io/code-generator/cmd/defaulter-gen
##TH##	touch $@
##TH##
##TH###
##TH### Conversion generation
##TH###
##TH### Any package that wants conversion functions generated must include one or
##TH### more comment-tags in any .go file, in column 0, of the form:
##TH###     // +k8s:conversion-gen=<CONVERSION_TARGET_DIR>
##TH###
##TH### The CONVERSION_TARGET_DIR is a project-local path to another directory which
##TH### should be considered when evaluating peer types for conversions.  Types which
##TH### are found in the source package (where conversions are being generated)
##TH### but do not have a peer in one of the target directories will not have
##TH### conversions generated.
##TH###
##TH### TODO: it might be better in the long term to make peer-types explicit in the
##TH### IDL.
##TH##
##TH### The result file, in each pkg, of conversion generation.
##TH##CONVERSION_BASENAME := $(GENERATED_FILE_PREFIX)conversion
##TH##CONVERSION_FILENAME := $(CONVERSION_BASENAME).go
##TH##
##TH### The tool used to generate conversions.
##TH##CONVERSION_GEN := $(BIN_DIR)/conversion-gen
##TH##
##TH### The name of the metadata file listing conversion peers for each pkg.
##TH##CONVERSIONS_META := conversions.mk
##TH##
##TH### All directories that request any form of conversion generation.
##TH##ifeq ($(DBG_MAKEFILE),1)
##TH##    $(warning ***** finding all +k8s:conversion-gen tags)
##TH##endif
##TH##CONVERSION_DIRS := $(shell                                              \
##TH##    grep --color=never '^// *+k8s:conversion-gen=' $(ALL_K8S_TAG_FILES) \
##TH##        | cut -f1 -d:                                                   \
##TH##        | xargs -n1 dirname                                             \
##TH##        | LC_ALL=C sort -u                                              \
##TH##)
##TH##
##TH##CONVERSION_FILES := $(addsuffix /$(CONVERSION_FILENAME), $(CONVERSION_DIRS))
##TH##CONVERSION_EXTRA_PEER_DIRS := k8s.io/kubernetes/pkg/apis/core,k8s.io/kubernetes/pkg/apis/core/v1,k8s.io/api/core/v1
##TH##
##TH### This rule aggregates the set of files to generate and then generates them all
##TH### in a single run of the tool.
##TH##.PHONY: gen_conversion
##TH##gen_conversion: $(CONVERSION_FILES) $(CONVERSION_GEN)
##TH##	if [[ -s $(META_DIR)/$(CONVERSION_GEN).todo ]]; then                 \
##TH##	    pkgs=$$(cat $(META_DIR)/$(CONVERSION_GEN).todo | paste -sd, -);  \
##TH##	    if [[ "$(DBG_CODEGEN)" == 1 ]]; then                             \
##TH##	        echo "DBG: running $(CONVERSION_GEN) for $$pkgs";            \
##TH##	    fi;                                                              \
##TH##	    ./hack/run-in-gopath.sh $(CONVERSION_GEN)                        \
##TH##	        --extra-peer-dirs $(CONVERSION_EXTRA_PEER_DIRS)              \
##TH##	        --v $(KUBE_VERBOSE)                                          \
##TH##	        --logtostderr                                                \
##TH##	        -i "$$pkgs"                                                  \
##TH##	        -O $(CONVERSION_BASENAME)                                    \
##TH##	        "$$@";                                                       \
##TH##	fi
##TH##
##TH### Establish a dependency between the deps file and the dir.  Whenever a dir
##TH### changes (files added or removed) the deps file will be considered stale.
##TH###
##TH### This is looser than we really need (e.g. we don't really care about non *.go
##TH### files or even *_test.go files), but this is much easier to represent.
##TH###
##TH### Because we 'sinclude' the deps file, it is considered for rebuilding, as part
##TH### of make's normal evaluation.  If it gets rebuilt, make will restart.
##TH###
##TH### The '$(eval)' is needed because this has a different RHS for each LHS, and
##TH### would otherwise produce results that make can't parse.
##TH##$(foreach dir, $(CONVERSION_DIRS), $(eval           \
##TH##    $(META_DIR)/$(dir)/$(CONVERSIONS_META): $(dir)  \
##TH##))
##TH##
##TH### How to rebuild a deps file.  When make determines that the deps file is stale
##TH### (see above), it executes this rule, and then re-loads the deps file.
##TH###
##TH### This is looser than we really need (e.g. we don't really care about test
##TH### files), but this is MUCH faster than calling `go list`.
##TH###
##TH### We regenerate the output file in order to satisfy make's "newer than" rules,
##TH### but we only need to rebuild targets if the contents actually changed.  That
##TH### is what the .stamp file represents.
##TH##$(foreach dir, $(CONVERSION_DIRS),  \
##TH##    $(META_DIR)/$(dir)/$(CONVERSIONS_META)):
##TH##	TAGS=$$(grep --color=never -h '^// *+k8s:conversion-gen=' $</*.go   \
##TH##	    | cut -f2- -d=                                                  \
##TH##	    | sed 's|$(PRJ_SRC_PATH)/||'                                    \
##TH##	    | sed 's|^k8s.io/|vendor/k8s.io/|');                            \
##TH##	mkdir -p $(@D);                                                     \
##TH##	echo "conversions__$< := $$(echo $${TAGS})" >$@.tmp;                \
##TH##	if ! cmp -s $@.tmp $@; then                                         \
##TH##	    if [[ "$(DBG_CODEGEN)" == 1 ]]; then                            \
##TH##	        echo "DBG: conversions changed for $@";                     \
##TH##	    fi;                                                             \
##TH##	    touch $@.stamp;                                                 \
##TH##	fi;                                                                 \
##TH##	mv $@.tmp $@
##TH##
##TH### Include any deps files as additional Makefile rules.  This triggers make to
##TH### consider the deps files for rebuild, which makes the whole
##TH### dependency-management logic work.  'sinclude' is "silent include" which does
##TH### not fail if the file does not exist.
##TH##$(foreach dir, $(CONVERSION_DIRS), $(eval            \
##TH##    sinclude $(META_DIR)/$(dir)/$(CONVERSIONS_META)  \
##TH##))
##TH##
##TH### For each dir in CONVERSION_DIRS, this establishes a dependency between the
##TH### output file and the input files that should trigger a rebuild.
##TH###
##TH### The variable value was set in $(GOFILES_META) and included as part of the
##TH### dependency management logic.
##TH###
##TH### Note that this is a deps-only statement, not a full rule (see below).  This
##TH### has to be done in a distinct step because wildcards don't work in static
##TH### pattern rules.
##TH###
##TH### The '$(eval)' is needed because this has a different RHS for each LHS, and
##TH### would otherwise produce results that make can't parse.
##TH###
##TH### We depend on the $(GOFILES_META).stamp to detect when the set of input files
##TH### has changed.  This allows us to detect deleted input files.
##TH##$(foreach dir, $(CONVERSION_DIRS), $(eval                                    \
##TH##    $(dir)/$(CONVERSION_FILENAME): $(META_DIR)/$(dir)/$(GOFILES_META).stamp  \
##TH##                                   $(gofiles__$(dir))                        \
##TH##))
##TH##
##TH### For each dir in CONVERSION_DIRS, for each target in $(conversions__$(dir)),
##TH### this establishes a dependency between the output file and the input files
##TH### that should trigger a rebuild.
##TH###
##TH### The variable value was set in $(GOFILES_META) and included as part of the
##TH### dependency management logic.
##TH###
##TH### Note that this is a deps-only statement, not a full rule (see below).  This
##TH### has to be done in a distinct step because wildcards don't work in static
##TH### pattern rules.
##TH###
##TH### The '$(eval)' is needed because this has a different RHS for each LHS, and
##TH### would otherwise produce results that make can't parse.
##TH###
##TH### We depend on the $(GOFILES_META).stamp to detect when the set of input files
##TH### has changed.  This allows us to detect deleted input files.
##TH##$(foreach dir, $(CONVERSION_DIRS),                                               \
##TH##    $(foreach tgt, $(conversions__$(dir)), $(eval                                \
##TH##        $(dir)/$(CONVERSION_FILENAME): $(META_DIR)/$(tgt)/$(GOFILES_META).stamp  \
##TH##                                       $(gofiles__$(tgt))                        \
##TH##    ))                                                                           \
##TH##)
##TH##
##TH### Unilaterally remove any leftovers from previous runs.
##TH##$(shell rm -f $(META_DIR)/$(CONVERSION_GEN)*.todo)
##TH##
##TH### How to regenerate conversion code.  This is a little slow to run, so we batch
##TH### it up and trigger the batch from the 'generated_files' target.
##TH##$(CONVERSION_FILES): $(CONVERSION_GEN)
##TH##	mkdir -p $$(dirname $(META_DIR)/$(CONVERSION_GEN))
##TH##	if [[ "$(DBG_CODEGEN)" == 1 ]]; then          \
##TH##	    echo "DBG: conversion needed $(@D): $?";  \
##TH##	    ls -lf --full-time $@ $? || true;         \
##TH##	fi
##TH##	echo $(PRJ_SRC_PATH)/$(@D) >> $(META_DIR)/$(CONVERSION_GEN).todo
##TH##
##TH### This calculates the dependencies for the generator tool, so we only rebuild
##TH### it when needed.  It is PHONY so that it always runs, but it only updates the
##TH### file if the contents have actually changed.  We 'sinclude' this later.
##TH##.PHONY: $(META_DIR)/$(CONVERSION_GEN).mk
##TH##$(META_DIR)/$(CONVERSION_GEN).mk:
##TH##	mkdir -p $(@D);                                                       \
##TH##	(echo -n "$(CONVERSION_GEN): ";                                       \
##TH##	 ./hack/run-in-gopath.sh go list                                      \
##TH##	     -f '{{.ImportPath}}{{"\n"}}{{range .Deps}}{{.}}{{"\n"}}{{end}}'  \
##TH##	     ./vendor/k8s.io/code-generator/cmd/conversion-gen                \
##TH##	     | grep --color=never "^$(PRJ_SRC_PATH)/"                         \
##TH##	     | xargs ./hack/run-in-gopath.sh go list                          \
##TH##	         -f '{{$$d := .Dir}}{{$$d}}{{"\n"}}{{range .GoFiles}}{{$$d}}/{{.}}{{"\n"}}{{end}}'  \
##TH##	     | paste -sd' ' -                                                 \
##TH##	     | sed 's/ / \\=,/g'                                              \
##TH##	     | tr '=,' '\n\t'                                                 \
##TH##	     | sed "s|$$(pwd -P)/||";                                         \
##TH##	) > $@.tmp;                                                           \
##TH##	if ! cmp -s $@.tmp $@; then                                           \
##TH##	    if [[ "$(DBG_CODEGEN)" == 1 ]]; then                              \
##TH##	        echo "DBG: $(CONVERSION_GEN).mk changed";                     \
##TH##	    fi;                                                               \
##TH##	    cat $@.tmp > $@;                                                  \
##TH##	    rm -f $@.tmp;                                                     \
##TH##	fi
##TH##
##TH### Include dependency info for the generator tool.  This will cause the rule of
##TH### the same name to be considered and if it is updated, make will restart.
##TH##sinclude $(META_DIR)/$(CONVERSION_GEN).mk
##TH##
##TH### How to build the generator tool.  The deps for this are defined in
##TH### the $(CONVERSION_GEN).mk, above.
##TH###
##TH### A word on the need to touch: This rule might trigger if, for example, a
##TH### non-Go file was added or deleted from a directory on which this depends.
##TH### This target needs to be reconsidered, but Go realizes it doesn't actually
##TH### have to be rebuilt.  In that case, make will forever see the dependency as
##TH### newer than the binary, and try to rebuild it over and over.  So we touch it,
##TH### and make is happy.
##TH##$(CONVERSION_GEN):
##TH##	hack/make-rules/build.sh ./vendor/k8s.io/code-generator/cmd/conversion-gen
##TH##	touch $@
##TH##
##TH###
##TH### Open-api generation
##TH###
##TH### Any package that wants open-api functions generated must include a
##TH### comment-tag in column 0 of one file of the form:
##TH###     // +k8s:openapi-gen=true
##TH###
##TH### The result file, in each pkg, of open-api generation.
##TH##OPENAPI_BASENAME := $(GENERATED_FILE_PREFIX)openapi
##TH##OPENAPI_FILENAME := $(OPENAPI_BASENAME).go
##TH##OPENAPI_OUTPUT_PKG := pkg/generated/openapi
##TH##
##TH### The tool used to generate open apis.
##TH##OPENAPI_GEN := $(BIN_DIR)/openapi-gen
##TH##
##TH### Find all the directories that request open-api generation.
##TH##ifeq ($(DBG_MAKEFILE),1)
##TH##    $(warning ***** finding all +k8s:openapi-gen tags)
##TH##endif
##TH##OPENAPI_DIRS := $(shell                                             \
##TH##    grep --color=never -l '+k8s:openapi-gen=' $(ALL_K8S_TAG_FILES)  \
##TH##        | xargs -n1 dirname                                         \
##TH##        | LC_ALL=C sort -u                                          \
##TH##)
##TH##
##TH##OPENAPI_OUTFILE := $(OPENAPI_OUTPUT_PKG)/$(OPENAPI_FILENAME)
##TH##
##TH### This rule is the user-friendly entrypoint for openapi generation.
##TH##.PHONY: gen_openapi
##TH##gen_openapi: $(OPENAPI_OUTFILE) $(OPENAPI_GEN)
##TH##
##TH### For each dir in OPENAPI_DIRS, this establishes a dependency between the
##TH### output file and the input files that should trigger a rebuild.
##TH###
##TH### Note that this is a deps-only statement, not a full rule (see below).  This
##TH### has to be done in a distinct step because wildcards don't work in static
##TH### pattern rules.
##TH###
##TH### The '$(eval)' is needed because this has a different RHS for each LHS, and
##TH### would otherwise produce results that make can't parse.
##TH###
##TH### We depend on the $(GOFILES_META).stamp to detect when the set of input files
##TH### has changed.  This allows us to detect deleted input files.
##TH##$(foreach dir, $(OPENAPI_DIRS), $(eval                                     \
##TH##    $(OPENAPI_OUTFILE): $(META_DIR)/$(dir)/$(GOFILES_META).stamp           \
##TH##                                 $(gofiles__$(dir))                        \
##TH##))
##TH##
##TH### How to regenerate open-api code.  This emits a single file for all results.
##TH##$(OPENAPI_OUTFILE): $(OPENAPI_GEN) $(OPENAPI_GEN)
##TH##	function run_gen_openapi() {                                                        \
##TH##	    ./hack/run-in-gopath.sh $(OPENAPI_GEN)                                          \
##TH##	        --v $(KUBE_VERBOSE)                                                         \
##TH##	        --logtostderr                                                               \
##TH##	        -i $$(echo $(addprefix $(PRJ_SRC_PATH)/, $(OPENAPI_DIRS)) | sed 's/ /,/g')  \
##TH##	        -p $(PRJ_SRC_PATH)/$(OPENAPI_OUTPUT_PKG)                                    \
##TH##	        -O $(OPENAPI_BASENAME)                                                      \
##TH##	        "$$@";                                                                      \
##TH##	};                                                                                  \
##TH##	run_gen_openapi
##TH##
##TH### This calculates the dependencies for the generator tool, so we only rebuild
##TH### it when needed.  It is PHONY so that it always runs, but it only updates the
##TH### file if the contents have actually changed.  We 'sinclude' this later.
##TH##.PHONY: $(META_DIR)/$(OPENAPI_GEN).mk
##TH##$(META_DIR)/$(OPENAPI_GEN).mk:
##TH##	mkdir -p $(@D);                                                       \
##TH##	(echo -n "$(OPENAPI_GEN): ";                                          \
##TH##	 ./hack/run-in-gopath.sh go list                                      \
##TH##	     -f '{{.ImportPath}}{{"\n"}}{{range .Deps}}{{.}}{{"\n"}}{{end}}'  \
##TH##	     ./vendor/k8s.io/code-generator/cmd/openapi-gen                   \
##TH##	     | grep --color=never "^$(PRJ_SRC_PATH)/"                         \
##TH##	     | xargs ./hack/run-in-gopath.sh go list                          \
##TH##	         -f '{{$$d := .Dir}}{{$$d}}{{"\n"}}{{range .GoFiles}}{{$$d}}/{{.}}{{"\n"}}{{end}}'  \
##TH##	     | paste -sd' ' -                                                 \
##TH##	     | sed 's/ / \\=,/g'                                              \
##TH##	     | tr '=,' '\n\t'                                                 \
##TH##	     | sed "s|$$(pwd -P)/||";                                         \
##TH##	) > $@.tmp;                                                           \
##TH##	if ! cmp -s $@.tmp $@; then                                           \
##TH##	    if [[ "$(DBG_CODEGEN)" == 1 ]]; then                              \
##TH##	        echo "DBG: $(OPENAPI_GEN).mk changed";                        \
##TH##	    fi;                                                               \
##TH##	    cat $@.tmp > $@;                                                  \
##TH##	    rm -f $@.tmp;                                                     \
##TH##	fi
##TH##
##TH### Include dependency info for the generator tool.  This will cause the rule of
##TH### the same name to be considered and if it is updated, make will restart.
##TH##sinclude $(META_DIR)/$(OPENAPI_GEN).mk
##TH##
##TH### How to build the generator tool.  The deps for this are defined in
##TH### the $(OPENAPI_GEN).mk, above.
##TH###
##TH### A word on the need to touch: This rule might trigger if, for example, a
##TH### non-Go file was added or deleted from a directory on which this depends.
##TH### This target needs to be reconsidered, but Go realizes it doesn't actually
##TH### have to be rebuilt.  In that case, make will forever see the dependency as
##TH### newer than the binary, and try to rebuild it over and over.  So we touch it,
##TH### and make is happy.
##TH##$(OPENAPI_GEN):
##TH##	hack/make-rules/build.sh ./vendor/k8s.io/code-generator/cmd/openapi-gen
##TH##	touch $@
##TH##
##TH###
##TH### bindata generation
##TH###
##TH##
##TH### The tool used to generate bindata files.
##TH##BINDATA_GEN := $(BIN_DIR)/go-bindata
##TH##
##TH### A wrapper script that generates all bindata files.  It is fast enough that we
##TH### don't care.
##TH##BINDATA_SCRIPT := hack/generate-bindata.sh
##TH##
##TH### This rule is the user-friendly entrypoint for bindata generation.
##TH##.PHONY: gen_bindata
##TH##gen_bindata: $(BINDATA_GEN) FORCE
##TH##	./hack/run-in-gopath.sh $(BINDATA_SCRIPT)
##TH##
##TH### This calculates the dependencies for the generator tool, so we only rebuild
##TH### it when needed.  It is PHONY so that it always runs, but it only updates the
##TH### file if the contents have actually changed.  We 'sinclude' this later.
##TH##.PHONY: $(META_DIR)/$(BINDATA_GEN).mk
##TH##$(META_DIR)/$(BINDATA_GEN).mk:
##TH##	mkdir -p $(@D);                                                       \
##TH##	(echo -n "$(BINDATA_GEN): ";                                          \
##TH##	 ./hack/run-in-gopath.sh go list                                      \
##TH##	     -f '{{.ImportPath}}{{"\n"}}{{range .Deps}}{{.}}{{"\n"}}{{end}}'  \
##TH##	     ./vendor/github.com/jteeuwen/go-bindata/go-bindata               \
##TH##	     | grep --color=never "^$(PRJ_SRC_PATH)/"                         \
##TH##	     | xargs ./hack/run-in-gopath.sh go list                          \
##TH##	         -f '{{$$d := .Dir}}{{$$d}}{{"\n"}}{{range .GoFiles}}{{$$d}}/{{.}}{{"\n"}}{{end}}'  \
##TH##	     | paste -sd' ' -                                                 \
##TH##	     | sed 's/ / \\=,/g'                                              \
##TH##	     | tr '=,' '\n\t'                                                 \
##TH##	     | sed "s|$$(pwd -P)/||";                                         \
##TH##	) > $@.tmp;                                                           \
##TH##	if ! cmp -s $@.tmp $@; then                                           \
##TH##	    if [[ "$(DBG_CODEGEN)" == 1 ]]; then                              \
##TH##	        echo "DBG: $(BINDATA_GEN).mk changed";                        \
##TH##	    fi;                                                               \
##TH##	    cat $@.tmp > $@;                                                  \
##TH##	    rm -f $@.tmp;                                                     \
##TH##	fi
##TH##
##TH### Include dependency info for the generator tool.  This will cause the rule of
##TH### the same name to be considered and if it is updated, make will restart.
##TH##sinclude $(META_DIR)/$(BINDATA_GEN).mk
##TH##
##TH### How to build the generator tool.  The deps for this are defined in
##TH### the $(BINDATA_GEN).mk, above.
##TH###
##TH### A word on the need to touch: This rule might trigger if, for example, a
##TH### non-Go file was added or deleted from a directory on which this depends.
##TH### This target needs to be reconsidered, but Go realizes it doesn't actually
##TH### have to be rebuilt.  In that case, make will forever see the dependency as
##TH### newer than the binary, and try to rebuild it over and over.  So we touch it,
##TH### and make is happy.
##TH##$(BINDATA_GEN):
##TH##	hack/make-rules/build.sh ./vendor/github.com/jteeuwen/go-bindata/go-bindata
##TH##	touch $@
