
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>volumemanager: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">k8s.io/kubernetes/pkg/kubelet/volumemanager/volume_manager.go (75.9%)</option>
				
				<option value="file1">k8s.io/kubernetes/pkg/kubelet/volumemanager/volume_manager_fake.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package volumemanager

import (
        "context"
        "errors"
        "fmt"
        "sort"
        "strconv"
        "strings"
        "time"

        utilfeature "k8s.io/apiserver/pkg/util/feature"
        "k8s.io/klog/v2"
        "k8s.io/mount-utils"

        v1 "k8s.io/api/core/v1"
        k8stypes "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/runtime"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/apimachinery/pkg/util/wait"
        clientset "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/record"
        csitrans "k8s.io/csi-translation-lib"
        "k8s.io/kubernetes/pkg/kubelet/config"
        "k8s.io/kubernetes/pkg/kubelet/container"
        "k8s.io/kubernetes/pkg/kubelet/volumemanager/cache"
        "k8s.io/kubernetes/pkg/kubelet/volumemanager/metrics"
        "k8s.io/kubernetes/pkg/kubelet/volumemanager/populator"
        "k8s.io/kubernetes/pkg/kubelet/volumemanager/reconciler"
        "k8s.io/kubernetes/pkg/volume"
        "k8s.io/kubernetes/pkg/volume/csimigration"
        "k8s.io/kubernetes/pkg/volume/util"
        "k8s.io/kubernetes/pkg/volume/util/hostutil"
        "k8s.io/kubernetes/pkg/volume/util/operationexecutor"
        "k8s.io/kubernetes/pkg/volume/util/types"
        "k8s.io/kubernetes/pkg/volume/util/volumepathhandler"
)

const (
        // reconcilerLoopSleepPeriod is the amount of time the reconciler loop waits
        // between successive executions
        reconcilerLoopSleepPeriod = 100 * time.Millisecond

        // desiredStateOfWorldPopulatorLoopSleepPeriod is the amount of time the
        // DesiredStateOfWorldPopulator loop waits between successive executions
        desiredStateOfWorldPopulatorLoopSleepPeriod = 100 * time.Millisecond

        // podAttachAndMountTimeout is the maximum amount of time the
        // WaitForAttachAndMount call will wait for all volumes in the specified pod
        // to be attached and mounted. Even though cloud operations can take several
        // minutes to complete, we set the timeout to 2 minutes because kubelet
        // will retry in the next sync iteration. This frees the associated
        // goroutine of the pod to process newer updates if needed (e.g., a delete
        // request to the pod).
        // Value is slightly offset from 2 minutes to make timeouts due to this
        // constant recognizable.
        podAttachAndMountTimeout = 2*time.Minute + 3*time.Second

        // podAttachAndMountRetryInterval is the amount of time the GetVolumesForPod
        // call waits before retrying
        podAttachAndMountRetryInterval = 300 * time.Millisecond

        // waitForAttachTimeout is the maximum amount of time a
        // operationexecutor.Mount call will wait for a volume to be attached.
        // Set to 10 minutes because we've seen attach operations take several
        // minutes to complete for some volume plugins in some cases. While this
        // operation is waiting it only blocks other operations on the same device,
        // other devices are not affected.
        waitForAttachTimeout = 10 * time.Minute
)

// VolumeManager runs a set of asynchronous loops that figure out which volumes
// need to be attached/mounted/unmounted/detached based on the pods scheduled on
// this node and makes it so.
type VolumeManager interface {
        // Starts the volume manager and all the asynchronous loops that it controls
        Run(sourcesReady config.SourcesReady, stopCh &lt;-chan struct{})

        // WaitForAttachAndMount processes the volumes referenced in the specified
        // pod and blocks until they are all attached and mounted (reflected in
        // actual state of the world).
        // An error is returned if all volumes are not attached and mounted within
        // the duration defined in podAttachAndMountTimeout.
        WaitForAttachAndMount(ctx context.Context, pod *v1.Pod) error

        // WaitForUnmount processes the volumes referenced in the specified
        // pod and blocks until they are all unmounted (reflected in the actual
        // state of the world).
        // An error is returned if all volumes are not unmounted within
        // the duration defined in podAttachAndMountTimeout.
        WaitForUnmount(ctx context.Context, pod *v1.Pod) error

        // GetMountedVolumesForPod returns a VolumeMap containing the volumes
        // referenced by the specified pod that are successfully attached and
        // mounted. The key in the map is the OuterVolumeSpecName (i.e.
        // pod.Spec.Volumes[x].Name). It returns an empty VolumeMap if pod has no
        // volumes.
        GetMountedVolumesForPod(podName types.UniquePodName) container.VolumeMap

        // GetPossiblyMountedVolumesForPod returns a VolumeMap containing the volumes
        // referenced by the specified pod that are either successfully attached
        // and mounted or are "uncertain", i.e. a volume plugin may be mounting
        // them right now. The key in the map is the OuterVolumeSpecName (i.e.
        // pod.Spec.Volumes[x].Name). It returns an empty VolumeMap if pod has no
        // volumes.
        GetPossiblyMountedVolumesForPod(podName types.UniquePodName) container.VolumeMap

        // GetExtraSupplementalGroupsForPod returns a list of the extra
        // supplemental groups for the Pod. These extra supplemental groups come
        // from annotations on persistent volumes that the pod depends on.
        GetExtraSupplementalGroupsForPod(pod *v1.Pod) []int64

        // GetVolumesInUse returns a list of all volumes that implement the volume.Attacher
        // interface and are currently in use according to the actual and desired
        // state of the world caches. A volume is considered "in use" as soon as it
        // is added to the desired state of world, indicating it *should* be
        // attached to this node and remains "in use" until it is removed from both
        // the desired state of the world and the actual state of the world, or it
        // has been unmounted (as indicated in actual state of world).
        GetVolumesInUse() []v1.UniqueVolumeName

        // ReconcilerStatesHasBeenSynced returns true only after the actual states in reconciler
        // has been synced at least once after kubelet starts so that it is safe to update mounted
        // volume list retrieved from actual state.
        ReconcilerStatesHasBeenSynced() bool

        // VolumeIsAttached returns true if the given volume is attached to this
        // node.
        VolumeIsAttached(volumeName v1.UniqueVolumeName) bool

        // Marks the specified volume as having successfully been reported as "in
        // use" in the nodes's volume status.
        MarkVolumesAsReportedInUse(volumesReportedAsInUse []v1.UniqueVolumeName)
}

// podStateProvider can determine if a pod is going to be terminated
type PodStateProvider interface {
        ShouldPodContainersBeTerminating(k8stypes.UID) bool
        ShouldPodRuntimeBeRemoved(k8stypes.UID) bool
}

// PodManager is the subset of methods the manager needs to observe the actual state of the kubelet.
// See pkg/k8s.io/kubernetes/pkg/kubelet/pod.Manager for method godoc.
type PodManager interface {
        GetPodByUID(k8stypes.UID) (*v1.Pod, bool)
        GetPods() []*v1.Pod
}

// NewVolumeManager returns a new concrete instance implementing the
// VolumeManager interface.
//
// kubeClient - kubeClient is the kube API client used by DesiredStateOfWorldPopulator
// to communicate with the API server to fetch PV and PVC objects
//
// volumePluginMgr - the volume plugin manager used to access volume plugins.
// Must be pre-initialized.
func NewVolumeManager(
        controllerAttachDetachEnabled bool,
        nodeName k8stypes.NodeName,
        podManager PodManager,
        podStateProvider PodStateProvider,
        kubeClient clientset.Interface,
        volumePluginMgr *volume.VolumePluginMgr,
        kubeContainerRuntime container.Runtime,
        mounter mount.Interface,
        hostutil hostutil.HostUtils,
        kubeletPodsDir string,
        recorder record.EventRecorder,
        keepTerminatedPodVolumes bool,
        blockVolumePathHandler volumepathhandler.BlockVolumePathHandler) VolumeManager <span class="cov8" title="1">{

        seLinuxTranslator := util.NewSELinuxLabelTranslator()
        vm := &amp;volumeManager{
                kubeClient:          kubeClient,
                volumePluginMgr:     volumePluginMgr,
                desiredStateOfWorld: cache.NewDesiredStateOfWorld(volumePluginMgr, seLinuxTranslator),
                actualStateOfWorld:  cache.NewActualStateOfWorld(nodeName, volumePluginMgr),
                operationExecutor: operationexecutor.NewOperationExecutor(operationexecutor.NewOperationGenerator(
                        kubeClient,
                        volumePluginMgr,
                        recorder,
                        blockVolumePathHandler)),
        }

        intreeToCSITranslator := csitrans.New()
        csiMigratedPluginManager := csimigration.NewPluginManager(intreeToCSITranslator, utilfeature.DefaultFeatureGate)

        vm.intreeToCSITranslator = intreeToCSITranslator
        vm.csiMigratedPluginManager = csiMigratedPluginManager
        vm.desiredStateOfWorldPopulator = populator.NewDesiredStateOfWorldPopulator(
                kubeClient,
                desiredStateOfWorldPopulatorLoopSleepPeriod,
                podManager,
                podStateProvider,
                vm.desiredStateOfWorld,
                vm.actualStateOfWorld,
                kubeContainerRuntime,
                keepTerminatedPodVolumes,
                csiMigratedPluginManager,
                intreeToCSITranslator,
                volumePluginMgr)
        vm.reconciler = reconciler.NewReconciler(
                kubeClient,
                controllerAttachDetachEnabled,
                reconcilerLoopSleepPeriod,
                waitForAttachTimeout,
                nodeName,
                vm.desiredStateOfWorld,
                vm.actualStateOfWorld,
                vm.desiredStateOfWorldPopulator.HasAddedPods,
                vm.operationExecutor,
                mounter,
                hostutil,
                volumePluginMgr,
                kubeletPodsDir)

        return vm
}</span>

// volumeManager implements the VolumeManager interface
type volumeManager struct {
        // kubeClient is the kube API client used by DesiredStateOfWorldPopulator to
        // communicate with the API server to fetch PV and PVC objects
        kubeClient clientset.Interface

        // volumePluginMgr is the volume plugin manager used to access volume
        // plugins. It must be pre-initialized.
        volumePluginMgr *volume.VolumePluginMgr

        // desiredStateOfWorld is a data structure containing the desired state of
        // the world according to the volume manager: i.e. what volumes should be
        // attached and which pods are referencing the volumes).
        // The data structure is populated by the desired state of the world
        // populator using the kubelet pod manager.
        desiredStateOfWorld cache.DesiredStateOfWorld

        // actualStateOfWorld is a data structure containing the actual state of
        // the world according to the manager: i.e. which volumes are attached to
        // this node and what pods the volumes are mounted to.
        // The data structure is populated upon successful completion of attach,
        // detach, mount, and unmount actions triggered by the reconciler.
        actualStateOfWorld cache.ActualStateOfWorld

        // operationExecutor is used to start asynchronous attach, detach, mount,
        // and unmount operations.
        operationExecutor operationexecutor.OperationExecutor

        // reconciler runs an asynchronous periodic loop to reconcile the
        // desiredStateOfWorld with the actualStateOfWorld by triggering attach,
        // detach, mount, and unmount operations using the operationExecutor.
        reconciler reconciler.Reconciler

        // desiredStateOfWorldPopulator runs an asynchronous periodic loop to
        // populate the desiredStateOfWorld using the kubelet PodManager.
        desiredStateOfWorldPopulator populator.DesiredStateOfWorldPopulator

        // csiMigratedPluginManager keeps track of CSI migration status of plugins
        csiMigratedPluginManager csimigration.PluginManager

        // intreeToCSITranslator translates in-tree volume specs to CSI
        intreeToCSITranslator csimigration.InTreeToCSITranslator
}

func (vm *volumeManager) Run(sourcesReady config.SourcesReady, stopCh &lt;-chan struct{}) <span class="cov8" title="1">{
        defer runtime.HandleCrash()

        if vm.kubeClient != nil </span><span class="cov8" title="1">{
                // start informer for CSIDriver
                go vm.volumePluginMgr.Run(stopCh)
        }</span>

        <span class="cov8" title="1">go vm.desiredStateOfWorldPopulator.Run(sourcesReady, stopCh)
        klog.V(2).InfoS("The desired_state_of_world populator starts")

        klog.InfoS("Starting Kubelet Volume Manager")
        go vm.reconciler.Run(stopCh)

        metrics.Register(vm.actualStateOfWorld, vm.desiredStateOfWorld, vm.volumePluginMgr)

        &lt;-stopCh
        klog.InfoS("Shutting down Kubelet Volume Manager")</span>
}

func (vm *volumeManager) GetMountedVolumesForPod(podName types.UniquePodName) container.VolumeMap <span class="cov8" title="1">{
        podVolumes := make(container.VolumeMap)
        for _, mountedVolume := range vm.actualStateOfWorld.GetMountedVolumesForPod(podName) </span><span class="cov8" title="1">{
                podVolumes[mountedVolume.OuterVolumeSpecName] = container.VolumeInfo{
                        Mounter:             mountedVolume.Mounter,
                        BlockVolumeMapper:   mountedVolume.BlockVolumeMapper,
                        ReadOnly:            mountedVolume.VolumeSpec.ReadOnly,
                        InnerVolumeSpecName: mountedVolume.InnerVolumeSpecName,
                }
        }</span>
        <span class="cov8" title="1">return podVolumes</span>
}

func (vm *volumeManager) GetPossiblyMountedVolumesForPod(podName types.UniquePodName) container.VolumeMap <span class="cov0" title="0">{
        podVolumes := make(container.VolumeMap)
        for _, mountedVolume := range vm.actualStateOfWorld.GetPossiblyMountedVolumesForPod(podName) </span><span class="cov0" title="0">{
                podVolumes[mountedVolume.OuterVolumeSpecName] = container.VolumeInfo{
                        Mounter:             mountedVolume.Mounter,
                        BlockVolumeMapper:   mountedVolume.BlockVolumeMapper,
                        ReadOnly:            mountedVolume.VolumeSpec.ReadOnly,
                        InnerVolumeSpecName: mountedVolume.InnerVolumeSpecName,
                }
        }</span>
        <span class="cov0" title="0">return podVolumes</span>
}

func (vm *volumeManager) GetExtraSupplementalGroupsForPod(pod *v1.Pod) []int64 <span class="cov8" title="1">{
        podName := util.GetUniquePodName(pod)
        supplementalGroups := sets.NewString()

        for _, mountedVolume := range vm.actualStateOfWorld.GetMountedVolumesForPod(podName) </span><span class="cov8" title="1">{
                if mountedVolume.VolumeGidValue != "" </span><span class="cov8" title="1">{
                        supplementalGroups.Insert(mountedVolume.VolumeGidValue)
                }</span>
        }

        <span class="cov8" title="1">result := make([]int64, 0, supplementalGroups.Len())
        for _, group := range supplementalGroups.List() </span><span class="cov8" title="1">{
                iGroup, extra := getExtraSupplementalGid(group, pod)
                if !extra </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">result = append(result, int64(iGroup))</span>
        }

        <span class="cov8" title="1">return result</span>
}

func (vm *volumeManager) GetVolumesInUse() []v1.UniqueVolumeName <span class="cov8" title="1">{
        // Report volumes in desired state of world and actual state of world so
        // that volumes are marked in use as soon as the decision is made that the
        // volume *should* be attached to this node until it is safely unmounted.
        desiredVolumes := vm.desiredStateOfWorld.GetVolumesToMount()
        allAttachedVolumes := vm.actualStateOfWorld.GetAttachedVolumes()
        volumesToReportInUse := make([]v1.UniqueVolumeName, 0, len(desiredVolumes)+len(allAttachedVolumes))
        desiredVolumesMap := make(map[v1.UniqueVolumeName]bool, len(desiredVolumes)+len(allAttachedVolumes))

        for _, volume := range desiredVolumes </span><span class="cov8" title="1">{
                if volume.PluginIsAttachable </span><span class="cov8" title="1">{
                        if _, exists := desiredVolumesMap[volume.VolumeName]; !exists </span><span class="cov8" title="1">{
                                desiredVolumesMap[volume.VolumeName] = true
                                volumesToReportInUse = append(volumesToReportInUse, volume.VolumeName)
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, volume := range allAttachedVolumes </span><span class="cov8" title="1">{
                if volume.PluginIsAttachable </span><span class="cov8" title="1">{
                        if _, exists := desiredVolumesMap[volume.VolumeName]; !exists </span><span class="cov0" title="0">{
                                volumesToReportInUse = append(volumesToReportInUse, volume.VolumeName)
                        }</span>
                }
        }

        <span class="cov8" title="1">sort.Slice(volumesToReportInUse, func(i, j int) bool </span><span class="cov0" title="0">{
                return string(volumesToReportInUse[i]) &lt; string(volumesToReportInUse[j])
        }</span>)
        <span class="cov8" title="1">return volumesToReportInUse</span>
}

func (vm *volumeManager) ReconcilerStatesHasBeenSynced() bool <span class="cov0" title="0">{
        return vm.reconciler.StatesHasBeenSynced()
}</span>

func (vm *volumeManager) VolumeIsAttached(
        volumeName v1.UniqueVolumeName) bool <span class="cov0" title="0">{
        return vm.actualStateOfWorld.VolumeExists(volumeName)
}</span>

func (vm *volumeManager) MarkVolumesAsReportedInUse(
        volumesReportedAsInUse []v1.UniqueVolumeName) <span class="cov8" title="1">{
        vm.desiredStateOfWorld.MarkVolumesReportedInUse(volumesReportedAsInUse)
}</span>

func (vm *volumeManager) WaitForAttachAndMount(ctx context.Context, pod *v1.Pod) error <span class="cov8" title="1">{
        if pod == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">expectedVolumes := getExpectedVolumes(pod)
        if len(expectedVolumes) == 0 </span><span class="cov0" title="0">{
                // No volumes to verify
                return nil
        }</span>

        <span class="cov8" title="1">klog.V(3).InfoS("Waiting for volumes to attach and mount for pod", "pod", klog.KObj(pod))
        uniquePodName := util.GetUniquePodName(pod)

        // Some pods expect to have Setup called over and over again to update.
        // Remount plugins for which this is true. (Atomically updating volumes,
        // like Downward API, depend on this to update the contents of the volume).
        vm.desiredStateOfWorldPopulator.ReprocessPod(uniquePodName)

        err := wait.PollUntilContextTimeout(
                ctx,
                podAttachAndMountRetryInterval,
                podAttachAndMountTimeout,
                true,
                vm.verifyVolumesMountedFunc(uniquePodName, expectedVolumes))

        if err != nil </span><span class="cov8" title="1">{
                unmountedVolumes :=
                        vm.getUnmountedVolumes(uniquePodName, expectedVolumes)
                // Also get unattached volumes and volumes not in dsw for error message
                unattachedVolumes :=
                        vm.getUnattachedVolumes(uniquePodName)
                volumesNotInDSW :=
                        vm.getVolumesNotInDSW(uniquePodName, expectedVolumes)

                if len(unmountedVolumes) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">return fmt.Errorf(
                        "unmounted volumes=%v, unattached volumes=%v, failed to process volumes=%v: %w",
                        unmountedVolumes,
                        unattachedVolumes,
                        volumesNotInDSW,
                        err)</span>
        }

        <span class="cov8" title="1">klog.V(3).InfoS("All volumes are attached and mounted for pod", "pod", klog.KObj(pod))
        return nil</span>
}

func (vm *volumeManager) WaitForUnmount(ctx context.Context, pod *v1.Pod) error <span class="cov0" title="0">{
        if pod == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">klog.V(3).InfoS("Waiting for volumes to unmount for pod", "pod", klog.KObj(pod))
        uniquePodName := util.GetUniquePodName(pod)

        vm.desiredStateOfWorldPopulator.ReprocessPod(uniquePodName)

        err := wait.PollUntilContextTimeout(
                ctx,
                podAttachAndMountRetryInterval,
                podAttachAndMountTimeout,
                true,
                vm.verifyVolumesUnmountedFunc(uniquePodName))

        if err != nil </span><span class="cov0" title="0">{
                var mountedVolumes []string
                for _, v := range vm.actualStateOfWorld.GetMountedVolumesForPod(uniquePodName) </span><span class="cov0" title="0">{
                        mountedVolumes = append(mountedVolumes, v.OuterVolumeSpecName)
                }</span>
                <span class="cov0" title="0">sort.Strings(mountedVolumes)

                if len(mountedVolumes) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return fmt.Errorf(
                        "mounted volumes=%v: %w",
                        mountedVolumes,
                        err)</span>
        }

        <span class="cov0" title="0">klog.V(3).InfoS("All volumes are unmounted for pod", "pod", klog.KObj(pod))
        return nil</span>
}

func (vm *volumeManager) getVolumesNotInDSW(uniquePodName types.UniquePodName, expectedVolumes []string) []string <span class="cov8" title="1">{
        volumesNotInDSW := sets.NewString(expectedVolumes...)

        for _, volumeToMount := range vm.desiredStateOfWorld.GetVolumesToMount() </span><span class="cov8" title="1">{
                if volumeToMount.PodName == uniquePodName </span><span class="cov8" title="1">{
                        volumesNotInDSW.Delete(volumeToMount.OuterVolumeSpecName)
                }</span>
        }

        <span class="cov8" title="1">return volumesNotInDSW.List()</span>
}

// getUnattachedVolumes returns a list of the volumes that are expected to be attached but
// are not currently attached to the node
func (vm *volumeManager) getUnattachedVolumes(uniquePodName types.UniquePodName) []string <span class="cov8" title="1">{
        unattachedVolumes := []string{}
        for _, volumeToMount := range vm.desiredStateOfWorld.GetVolumesToMount() </span><span class="cov8" title="1">{
                if volumeToMount.PodName == uniquePodName &amp;&amp;
                        volumeToMount.PluginIsAttachable &amp;&amp;
                        !vm.actualStateOfWorld.VolumeExists(volumeToMount.VolumeName) </span><span class="cov8" title="1">{
                        unattachedVolumes = append(unattachedVolumes, volumeToMount.OuterVolumeSpecName)
                }</span>
        }
        <span class="cov8" title="1">sort.Strings(unattachedVolumes)

        return unattachedVolumes</span>
}

// verifyVolumesMountedFunc returns a method that returns true when all expected
// volumes are mounted.
func (vm *volumeManager) verifyVolumesMountedFunc(podName types.UniquePodName, expectedVolumes []string) wait.ConditionWithContextFunc <span class="cov8" title="1">{
        return func(_ context.Context) (done bool, err error) </span><span class="cov8" title="1">{
                if errs := vm.desiredStateOfWorld.PopPodErrors(podName); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        return true, errors.New(strings.Join(errs, "; "))
                }</span>
                <span class="cov8" title="1">return len(vm.getUnmountedVolumes(podName, expectedVolumes)) == 0, nil</span>
        }
}

// verifyVolumesUnmountedFunc returns a method that is true when there are no mounted volumes for this
// pod.
func (vm *volumeManager) verifyVolumesUnmountedFunc(podName types.UniquePodName) wait.ConditionWithContextFunc <span class="cov0" title="0">{
        return func(_ context.Context) (done bool, err error) </span><span class="cov0" title="0">{
                if errs := vm.desiredStateOfWorld.PopPodErrors(podName); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                        return true, errors.New(strings.Join(errs, "; "))
                }</span>
                <span class="cov0" title="0">return len(vm.actualStateOfWorld.GetMountedVolumesForPod(podName)) == 0, nil</span>
        }
}

// getUnmountedVolumes fetches the current list of mounted volumes from
// the actual state of the world, and uses it to process the list of
// expectedVolumes. It returns a list of unmounted volumes.
// The list also includes volume that may be mounted in uncertain state.
func (vm *volumeManager) getUnmountedVolumes(podName types.UniquePodName, expectedVolumes []string) []string <span class="cov8" title="1">{
        mountedVolumes := sets.NewString()
        for _, mountedVolume := range vm.actualStateOfWorld.GetMountedVolumesForPod(podName) </span><span class="cov8" title="1">{
                mountedVolumes.Insert(mountedVolume.OuterVolumeSpecName)
        }</span>
        <span class="cov8" title="1">return filterUnmountedVolumes(mountedVolumes, expectedVolumes)</span>
}

// filterUnmountedVolumes adds each element of expectedVolumes that is not in
// mountedVolumes to a list of unmountedVolumes and returns it.
func filterUnmountedVolumes(mountedVolumes sets.String, expectedVolumes []string) []string <span class="cov8" title="1">{
        unmountedVolumes := []string{}
        for _, expectedVolume := range expectedVolumes </span><span class="cov8" title="1">{
                if !mountedVolumes.Has(expectedVolume) </span><span class="cov8" title="1">{
                        unmountedVolumes = append(unmountedVolumes, expectedVolume)
                }</span>
        }
        <span class="cov8" title="1">sort.Strings(unmountedVolumes)

        return unmountedVolumes</span>
}

// getExpectedVolumes returns a list of volumes that must be mounted in order to
// consider the volume setup step for this pod satisfied.
func getExpectedVolumes(pod *v1.Pod) []string <span class="cov8" title="1">{
        mounts, devices, _ := util.GetPodVolumeNames(pod)
        return mounts.Union(devices).UnsortedList()
}</span>

// getExtraSupplementalGid returns the value of an extra supplemental GID as
// defined by an annotation on a volume and a boolean indicating whether the
// volume defined a GID that the pod doesn't already request.
func getExtraSupplementalGid(volumeGidValue string, pod *v1.Pod) (int64, bool) <span class="cov8" title="1">{
        if volumeGidValue == "" </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov8" title="1">gid, err := strconv.ParseInt(volumeGidValue, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0, false
        }</span>

        <span class="cov8" title="1">if pod.Spec.SecurityContext != nil </span><span class="cov8" title="1">{
                for _, existingGid := range pod.Spec.SecurityContext.SupplementalGroups </span><span class="cov8" title="1">{
                        if gid == int64(existingGid) </span><span class="cov8" title="1">{
                                return 0, false
                        }</span>
                }
        }

        <span class="cov8" title="1">return gid, true</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package volumemanager

import (
        "context"

        v1 "k8s.io/api/core/v1"
        "k8s.io/kubernetes/pkg/kubelet/config"
        "k8s.io/kubernetes/pkg/kubelet/container"
        "k8s.io/kubernetes/pkg/volume/util/types"
)

// FakeVolumeManager is a test implementation that just tracks calls
type FakeVolumeManager struct {
        volumes       map[v1.UniqueVolumeName]bool
        reportedInUse map[v1.UniqueVolumeName]bool
}

// NewFakeVolumeManager creates a new VolumeManager test instance
func NewFakeVolumeManager(initialVolumes []v1.UniqueVolumeName) *FakeVolumeManager <span class="cov0" title="0">{
        volumes := map[v1.UniqueVolumeName]bool{}
        for _, v := range initialVolumes </span><span class="cov0" title="0">{
                volumes[v] = true
        }</span>
        <span class="cov0" title="0">return &amp;FakeVolumeManager{
                volumes:       volumes,
                reportedInUse: map[v1.UniqueVolumeName]bool{},
        }</span>
}

// Run is not implemented
func (f *FakeVolumeManager) Run(sourcesReady config.SourcesReady, stopCh &lt;-chan struct{}) {<span class="cov0" title="0">
}</span>

// WaitForAttachAndMount is not implemented
func (f *FakeVolumeManager) WaitForAttachAndMount(ctx context.Context, pod *v1.Pod) error <span class="cov0" title="0">{
        return nil
}</span>

// WaitForUnmount is not implemented
func (f *FakeVolumeManager) WaitForUnmount(ctx context.Context, pod *v1.Pod) error <span class="cov0" title="0">{
        return nil
}</span>

// GetMountedVolumesForPod is not implemented
func (f *FakeVolumeManager) GetMountedVolumesForPod(podName types.UniquePodName) container.VolumeMap <span class="cov0" title="0">{
        return nil
}</span>

// GetPossiblyMountedVolumesForPod is not implemented
func (f *FakeVolumeManager) GetPossiblyMountedVolumesForPod(podName types.UniquePodName) container.VolumeMap <span class="cov0" title="0">{
        return nil
}</span>

// GetExtraSupplementalGroupsForPod is not implemented
func (f *FakeVolumeManager) GetExtraSupplementalGroupsForPod(pod *v1.Pod) []int64 <span class="cov0" title="0">{
        return nil
}</span>

// GetVolumesInUse returns a list of the initial volumes
func (f *FakeVolumeManager) GetVolumesInUse() []v1.UniqueVolumeName <span class="cov0" title="0">{
        inuse := []v1.UniqueVolumeName{}
        for v := range f.volumes </span><span class="cov0" title="0">{
                inuse = append(inuse, v)
        }</span>
        <span class="cov0" title="0">return inuse</span>
}

// ReconcilerStatesHasBeenSynced is not implemented
func (f *FakeVolumeManager) ReconcilerStatesHasBeenSynced() bool <span class="cov0" title="0">{
        return true
}</span>

// VolumeIsAttached is not implemented
func (f *FakeVolumeManager) VolumeIsAttached(volumeName v1.UniqueVolumeName) bool <span class="cov0" title="0">{
        return false
}</span>

// MarkVolumesAsReportedInUse adds the given volumes to the reportedInUse map
func (f *FakeVolumeManager) MarkVolumesAsReportedInUse(volumesReportedAsInUse []v1.UniqueVolumeName) <span class="cov0" title="0">{
        for _, reportedVolume := range volumesReportedAsInUse </span><span class="cov0" title="0">{
                if _, ok := f.volumes[reportedVolume]; ok </span><span class="cov0" title="0">{
                        f.reportedInUse[reportedVolume] = true
                }</span>
        }
}

// GetVolumesReportedInUse is a test function only that returns a list of volumes
// from the reportedInUse map
func (f *FakeVolumeManager) GetVolumesReportedInUse() []v1.UniqueVolumeName <span class="cov0" title="0">{
        inuse := []v1.UniqueVolumeName{}
        for reportedVolume := range f.reportedInUse </span><span class="cov0" title="0">{
                inuse = append(inuse, reportedVolume)
        }</span>
        <span class="cov0" title="0">return inuse</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
